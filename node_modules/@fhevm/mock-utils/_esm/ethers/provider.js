import { ethers as EthersT } from "ethers";
import { FhevmError } from "../utils/error.js";
export async function minimalProviderSend(provider, method, params) {
    let response;
    if ("request" in provider && typeof provider.request === "function") {
        response = await provider.request({ method, params });
    }
    else if ("send" in provider && typeof provider.send === "function") {
        response = await provider.send(method, params);
    }
    else {
        throw new Error("Invalid provider: must implement request() or send()");
    }
    return response;
}
export async function getProviderChainId(provider) {
    const chainIdHex = await minimalProviderSend(provider, "eth_chainId", []);
    return Number(BigInt(chainIdHex));
}
// Not used
export async function getSignerChainId(signer) {
    const provider = signer.provider;
    if (!provider) {
        throw new FhevmError("Unable to determine signer provider");
    }
    const network = await provider.getNetwork();
    return Number(network.chainId);
}
export function canSign(obj) {
    if (!obj) {
        throw new FhevmError(`Invalid argument`);
    }
    const isDirectSigner = typeof obj.signTransaction === "function";
    const canProduceSigner = typeof obj.getSigner === "function";
    return isDirectSigner || canProduceSigner;
}
export function isReadonlyContract(contract) {
    return !canSign(contract.runner);
}
export function isReadonlyProvider(obj) {
    if (!obj) {
        throw new FhevmError(`Invalid argument`);
    }
    return (!canSign(obj) &&
        typeof obj.estimateGas === "function" &&
        typeof obj.call === "function" &&
        typeof obj.getBlock === "function" &&
        typeof obj.getNetwork === "function" &&
        typeof obj.getCode === "function");
}
//# sourceMappingURL=provider.js.map