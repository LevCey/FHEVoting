var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MockFhevmInstance_relayerProvider, _MockFhevmInstance_readonlyRunner, _MockFhevmInstance_chainId, _MockFhevmInstance_gatewayChainId, _MockFhevmInstance_verifyingContractAddressInputVerification, _MockFhevmInstance_verifyingContractAddressDecryption, _MockFhevmInstance_contractsChainId, _MockFhevmInstance_aclContractAddress, _MockFhevmInstance_kmsVerifier, _MockFhevmInstance_inputVerifier, _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc;
/*
    WARNING : Never import the "hardhat" package!
*/
import { ethers as EthersT } from "ethers";
import constants from "../constants.js";
import { buildUserDecryptedResult, checkDeadlineValidity, checkMaxContractAddresses, } from "../relayer-sdk/relayer/userDecrypt.js";
import { createEIP712 as fhevmSdkCreateEIP712ForDecryption, generateKeypair as fhevmSdkGenerateKeypair, } from "../relayer-sdk/types.js";
import { assertIsAddress, assertIsAddressArray } from "../utils/address.js";
import { FhevmError, assertFhevm } from "../utils/error.js";
import { fromHexString, toHexString } from "../utils/hex.js";
import { assertIsNumber } from "../utils/math.js";
import { MockRelayerEncryptedInput } from "./MockRelayerEncryptedInput.js";
import { InputVerifier } from "./contracts/InputVerifier.js";
import { KMSVerifier } from "./contracts/KMSVerifier.js";
import { requestRelayerV1UserDecrypt } from "./relayer/MockRelayer.js";
/*
  Only one instance is created for the whole HH session (including tests)
*/
export class MockFhevmInstance {
    constructor(config, extra) {
        _MockFhevmInstance_relayerProvider.set(this, void 0);
        _MockFhevmInstance_readonlyRunner.set(this, void 0);
        _MockFhevmInstance_chainId.set(this, void 0); //provider's chainId
        _MockFhevmInstance_gatewayChainId.set(this, void 0);
        _MockFhevmInstance_verifyingContractAddressInputVerification.set(this, void 0);
        _MockFhevmInstance_verifyingContractAddressDecryption.set(this, void 0);
        _MockFhevmInstance_contractsChainId.set(this, void 0);
        _MockFhevmInstance_aclContractAddress.set(this, void 0);
        _MockFhevmInstance_kmsVerifier.set(this, void 0);
        _MockFhevmInstance_inputVerifier.set(this, void 0);
        //#fhevmSdkModule: FhevmSdkModule;
        _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc.set(this, void 0);
        assertIsAddress(config.verifyingContractAddressInputVerification, "config.verifyingContractAddressInputVerification");
        assertIsAddress(config.verifyingContractAddressDecryption, "config.verifyingContractAddressDecryption");
        assertIsNumber(config.gatewayChainId, "config.gatewayChainId");
        __classPrivateFieldSet(this, _MockFhevmInstance_relayerProvider, extra.relayerProvider, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_readonlyRunner, extra.inputVerifier.runner, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_chainId, config.chainId, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_gatewayChainId, config.gatewayChainId, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_verifyingContractAddressInputVerification, config.verifyingContractAddressInputVerification, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_verifyingContractAddressDecryption, config.verifyingContractAddressDecryption, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_contractsChainId, config.chainId, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_aclContractAddress, config.aclContractAddress, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_kmsVerifier, extra.kmsVerifier, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_inputVerifier, extra.inputVerifier, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc, fhevmSdkCreateEIP712ForDecryption(__classPrivateFieldGet(this, _MockFhevmInstance_gatewayChainId, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_verifyingContractAddressDecryption, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_contractsChainId, "f")), "f");
    }
    get chainId() {
        return __classPrivateFieldGet(this, _MockFhevmInstance_chainId, "f");
    }
    static async create(readonlyRunner, relayerProvider, config) {
        const kmsVerifier = await KMSVerifier.create(readonlyRunner, config.kmsContractAddress);
        const inputVerifier = await InputVerifier.create(readonlyRunner, config.inputVerifierContractAddress);
        return new MockFhevmInstance(config, {
            relayerProvider,
            inputVerifier,
            kmsVerifier,
            //fhevmSdkModule,
        });
    }
    static createEIP712(
    //fhevmSdkModule: FhevmSdkModule,
    publicKey, contractAddresses, startTimestamp, durationDays, gatewayChainId, verifyingContractAddressDecryption, contractsChainId) {
        assertIsAddressArray(contractAddresses, "contractAddresses");
        //const eip712Func = fhevmSdkModule.createEIP712(
        const eip712Func = fhevmSdkCreateEIP712ForDecryption(gatewayChainId, verifyingContractAddressDecryption, contractsChainId);
        const eip712 = eip712Func(publicKey, contractAddresses, startTimestamp, durationDays);
        //Debug Make sure we are in sync with @fhevm/sdk
        assertFhevm(eip712.domain.version === constants.DECRYPTION_EIP712_DOMAIN.version.toString());
        assertFhevm(eip712.domain.name === constants.DECRYPTION_EIP712_DOMAIN.name);
        return eip712;
    }
    // Create EIP712 for decryption
    createEIP712(publicKey, contractAddresses, startTimestamp, durationDays) {
        assertIsAddressArray(contractAddresses, "contractAddresses");
        const eip712 = __classPrivateFieldGet(this, _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc, "f").call(this, publicKey, contractAddresses, startTimestamp, durationDays);
        //Debug Make sure we are in sync with @fhevm/sdk
        assertFhevm(eip712.domain.version === constants.DECRYPTION_EIP712_DOMAIN.version.toString());
        assertFhevm(eip712.domain.name === constants.DECRYPTION_EIP712_DOMAIN.name);
        //Debug Make sure we are in sync with KMSVerifier.sol
        assertFhevm(eip712.domain.verifyingContract === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.verifyingContract);
        assertFhevm(eip712.domain.version === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.version);
        assertFhevm(eip712.domain.name === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.name);
        assertFhevm(BigInt(eip712.domain.chainId) === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.chainId);
        return eip712;
    }
    get relayerProvider() {
        return __classPrivateFieldGet(this, _MockFhevmInstance_relayerProvider, "f");
    }
    createEncryptedInput(contractAddress, userAddress) {
        assertFhevm(constants.INPUT_VERIFICATION_EIP712_DOMAIN.name === __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.name);
        assertFhevm(constants.INPUT_VERIFICATION_EIP712_DOMAIN.version === __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.version);
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstance_verifyingContractAddressInputVerification, "f") === __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.verifyingContract);
        assertFhevm(BigInt(__classPrivateFieldGet(this, _MockFhevmInstance_gatewayChainId, "f")) === __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.chainId);
        return new MockRelayerEncryptedInput(this.relayerProvider, __classPrivateFieldGet(this, _MockFhevmInstance_chainId, "f"), contractAddress, userAddress, __classPrivateFieldGet(this, _MockFhevmInstance_aclContractAddress, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f"));
    }
    generateKeypair() {
        //return this.#fhevmSdkModule.generateKeypair();
        return fhevmSdkGenerateKeypair();
    }
    getPublicKey() {
        throw new FhevmError("Not supported in mock mode");
    }
    getPublicParams(_bits) {
        throw new FhevmError("Not supported in mock mode");
    }
    async publicDecrypt(_handle) {
        throw new FhevmError(`publicDecrypt is not yet supported in mock mode`);
    }
    async userDecrypt(handles, _privateKey, publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays) {
        // Intercept future type change...
        for (let i = 0; i < handles.length; ++i) {
            assertFhevm(typeof handles[i].handle === "string" || handles[i].handle instanceof Uint8Array, "handle is not a string or a Uint8Array");
        }
        // Casting handles if string
        const relayerHandles = handles.map((h) => ({
            handle: typeof h.handle === "string" ? toHexString(fromHexString(h.handle), true) : toHexString(h.handle, true),
            contractAddress: h.contractAddress,
        }));
        // relayer-sdk
        checkDeadlineValidity(BigInt(startTimestamp), BigInt(durationDays));
        await MockFhevmInstance.verifyACLPermissions(__classPrivateFieldGet(this, _MockFhevmInstance_readonlyRunner, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_aclContractAddress, "f"), relayerHandles, userAddress);
        // relayer-sdk
        checkMaxContractAddresses(contractAddresses);
        MockFhevmInstance.verifyHandleContractAddresses(relayerHandles, contractAddresses);
        // relayer-sdk
        const payloadForRequest = {
            handleContractPairs: relayerHandles,
            requestValidity: {
                startTimestamp: startTimestamp.toString(), // Convert to string
                durationDays: durationDays.toString(), // Convert to string
            },
            contractsChainId: __classPrivateFieldGet(this, _MockFhevmInstance_chainId, "f").toString(), // Convert to string
            contractAddresses: contractAddresses.map((c) => EthersT.getAddress(c)),
            userAddress: EthersT.getAddress(userAddress),
            signature: signature.replace(/^(0x)/, ""),
            publicKey: publicKey.replace(/^(0x)/, ""),
        };
        const clearTextHexList = await requestRelayerV1UserDecrypt(this.relayerProvider, payloadForRequest);
        await this._verifySignature(publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays);
        const listBigIntDecryptions = clearTextHexList.map(EthersT.toBigInt);
        const results = buildUserDecryptedResult(relayerHandles.map((h) => h.handle), listBigIntDecryptions);
        return results;
    }
    async _verifySignature(publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays) {
        const eip712 = this.createEIP712(publicKey, contractAddresses, startTimestamp, durationDays);
        if (!signature.startsWith("0x")) {
            signature = "0x" + signature;
        }
        const types = {};
        types[eip712.primaryType] = eip712.types[eip712.primaryType];
        const signerAddress = EthersT.verifyTypedData(eip712.domain, types, eip712.message, signature);
        const normalizedSignerAddress = EthersT.getAddress(signerAddress);
        const normalizedUserAddress = EthersT.getAddress(userAddress);
        if (normalizedSignerAddress !== normalizedUserAddress) {
            throw new FhevmError("Invalid EIP-712 signature!");
        }
    }
    // (Duplicated code) Should be imported from @fhevm/sdk
    static async verifyACLPermissions(runner, aclContractAddress, handles, userAddress) {
        const aclABI = ["function persistAllowed(bytes32 handle, address account) view returns (bool)"];
        const acl = new EthersT.Contract(aclContractAddress, aclABI, runner);
        const verifications = handles.map(async ({ handle, contractAddress }) => {
            const ctHandleHex = EthersT.toBeHex(EthersT.toBigInt(handle), 32);
            const userAllowed = await acl.persistAllowed(ctHandleHex, userAddress);
            const contractAllowed = await acl.persistAllowed(ctHandleHex, contractAddress);
            if (!userAllowed) {
                throw new FhevmError(`User ${userAddress} is not authorized to user decrypt handle ${handle}!`);
            }
            if (!contractAllowed) {
                throw new FhevmError(`dapp contract ${contractAddress} is not authorized to user decrypt handle ${handle}!`);
            }
            if (userAddress === contractAddress) {
                throw new FhevmError(`userAddress ${userAddress} should not be equal to contractAddress when requesting decryption!`);
            }
        });
        return Promise.all(verifications).catch((e) => {
            throw e;
        });
    }
    static verifyHandleContractAddresses(handles, contractAddresses) {
        const set = new Set();
        // Build a list of unique allowed contact addresses.
        for (let i = 0; i < contractAddresses.length; ++i) {
            const add = contractAddresses[i].toLowerCase();
            if (!set.has(add)) {
                set.add(add);
            }
        }
        // Check that every handle contract (in HandleContractPair) is actually listed in the contractAddresses argument.
        for (let i = 0; i < handles.length; ++i) {
            if (!set.has(handles[i].contractAddress.toLowerCase())) {
                throw new FhevmError(`Contract address ${handles[i].contractAddress} associated to handle ${handles[i].handle} is not listed in the contractAddresses array argument.`);
            }
        }
    }
}
_MockFhevmInstance_relayerProvider = new WeakMap(), _MockFhevmInstance_readonlyRunner = new WeakMap(), _MockFhevmInstance_chainId = new WeakMap(), _MockFhevmInstance_gatewayChainId = new WeakMap(), _MockFhevmInstance_verifyingContractAddressInputVerification = new WeakMap(), _MockFhevmInstance_verifyingContractAddressDecryption = new WeakMap(), _MockFhevmInstance_contractsChainId = new WeakMap(), _MockFhevmInstance_aclContractAddress = new WeakMap(), _MockFhevmInstance_kmsVerifier = new WeakMap(), _MockFhevmInstance_inputVerifier = new WeakMap(), _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc = new WeakMap();
//# sourceMappingURL=MockFhevmInstance.js.map