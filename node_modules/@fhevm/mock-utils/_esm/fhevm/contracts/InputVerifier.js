var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InputVerifier_inputVerifierContract, _InputVerifier_inputVerifierContractAddress, _InputVerifier_signers, _InputVerifier_threshold, _InputVerifier_eip712Domain;
import { ethers as EthersT } from "ethers";
import constants from "../../constants.js";
import { isThresholdReached } from "../../ethers/eip712.js";
import { assertIsAddress, assertIsAddressArray } from "../../utils/address.js";
import { assertIsBytes32String } from "../../utils/bytes.js";
import { FhevmError, assertFhevm, assertIsArray } from "../../utils/error.js";
import { numberToHexNoPrefix } from "../../utils/hex.js";
import { assertIsBigUint8, assertIsBigUint256 } from "../../utils/math.js";
import { assertIsString, ensurePrefix, removePrefix } from "../../utils/string.js";
const abiInputVerifier = [
    "function getCoprocessorSigners() view returns (address[])",
    "function getThreshold() view returns (uint256)",
    "function eip712Domain() view returns (bytes1,string,string,uint256,address,bytes32,uint256[])",
];
export class InputVerifier {
    constructor(runner, inputVerifierContractAddress) {
        _InputVerifier_inputVerifierContract.set(this, void 0);
        _InputVerifier_inputVerifierContractAddress.set(this, void 0);
        _InputVerifier_signers.set(this, void 0);
        _InputVerifier_threshold.set(this, void 0);
        _InputVerifier_eip712Domain.set(this, void 0);
        assertIsAddress(inputVerifierContractAddress, "inputVerifierContractAddress");
        __classPrivateFieldSet(this, _InputVerifier_inputVerifierContractAddress, inputVerifierContractAddress, "f");
        __classPrivateFieldSet(this, _InputVerifier_inputVerifierContract, new EthersT.Contract(inputVerifierContractAddress, abiInputVerifier, runner), "f");
    }
    get runner() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_inputVerifierContract, "f").runner);
        return __classPrivateFieldGet(this, _InputVerifier_inputVerifierContract, "f").runner;
    }
    static async create(runner, inputVerifierContractAddress) {
        const inputVerifier = new InputVerifier(runner, inputVerifierContractAddress);
        await inputVerifier.initialize();
        return inputVerifier;
    }
    async initialize() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_signers, "f") === undefined, `InputVerifier wrapper already initialized`);
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_threshold, "f") === undefined, `InputVerifier wrapper already initialized`);
        const signers = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierContract, "f").getCoprocessorSigners();
        assertIsAddressArray(signers);
        __classPrivateFieldSet(this, _InputVerifier_signers, signers, "f");
        const threshold = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierContract, "f").getThreshold();
        assertIsBigUint8(threshold);
        __classPrivateFieldSet(this, _InputVerifier_threshold, Number(threshold), "f");
        // ignore extensions
        const eip712Domain = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierContract, "f").eip712Domain();
        assertFhevm(eip712Domain.length === 7);
        assertIsString(eip712Domain[0], "eip712Domain[0]");
        assertIsString(eip712Domain[1], "eip712Domain[1]");
        assertIsString(eip712Domain[2], "eip712Domain[2]");
        assertIsBigUint256(eip712Domain[3], "eip712Domain[3]");
        assertIsAddress(eip712Domain[4], "eip712Domain[4]");
        assertIsBytes32String(eip712Domain[5], "eip712Domain[5]");
        __classPrivateFieldSet(this, _InputVerifier_eip712Domain, {
            fields: Number(BigInt(eip712Domain[0])),
            name: eip712Domain[1],
            version: eip712Domain[2],
            chainId: eip712Domain[3],
            verifyingContract: eip712Domain[4],
            salt: eip712Domain[5],
        }, "f");
        assertFhevm(constants.INPUT_VERIFICATION_EIP712_DOMAIN.name === __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").name);
        assertFhevm(constants.INPUT_VERIFICATION_EIP712_DOMAIN.version === __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").version);
    }
    get address() {
        return __classPrivateFieldGet(this, _InputVerifier_inputVerifierContractAddress, "f");
    }
    // The InputVerifier is always using the gatewayChainId in its eip712 domain
    get gatewayChainId() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").chainId;
    }
    // The InputVerifier is always using the address of the "InputVerification.sol" contract deployed
    // on the gateway chainId in its eip712 domain
    get gatewayInputVerificationAddress() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").verifyingContract;
    }
    get eip712Domain() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f");
    }
    getCoprocessorSigners() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_signers, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_signers, "f");
    }
    getThreshold() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_threshold, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_threshold, "f");
    }
    verifySignatures(handlesBytes32List, userAddress, contractAddress, contractChainId, signatures) {
        assertIsArray(signatures);
        const domain = {
            name: this.eip712Domain.name,
            version: this.eip712Domain.version,
            chainId: this.eip712Domain.chainId,
            verifyingContract: this.eip712Domain.verifyingContract,
        };
        const types = constants.INPUT_VERIFICATION_EIP712_TYPE;
        const recoveredAddresses = signatures.map((signature) => {
            const sig = ensurePrefix(signature, "0x");
            const recoveredAddress = EthersT.verifyTypedData(domain, types, {
                ctHandles: handlesBytes32List,
                userAddress,
                contractAddress,
                contractChainId,
            }, sig);
            return recoveredAddress;
        });
        if (!isThresholdReached(this.getCoprocessorSigners(), recoveredAddresses, this.getThreshold())) {
            throw new FhevmError("Coprocessor signers threshold is not reached");
        }
    }
    // See: fhevm-gateway/contracts/InputVerification.sol
    createCiphertextVerificationEIP712(handlesBytes32List, contractChainId, contractAddress, userAddress) {
        assertIsAddress(userAddress, "userAddress");
        assertIsAddress(contractAddress, "contractAddress");
        const eip712 = {
            domain: {
                chainId: this.gatewayChainId,
                name: this.eip712Domain.name,
                version: this.eip712Domain.version,
                verifyingContract: this.gatewayInputVerificationAddress,
            },
            types: constants.INPUT_VERIFICATION_EIP712_TYPE,
            message: {
                ctHandles: handlesBytes32List.map((handle) => EthersT.zeroPadValue(EthersT.toBeHex(handle), 32)),
                userAddress: userAddress,
                contractAddress: contractAddress,
                contractChainId: contractChainId,
            },
        };
        return eip712;
    }
}
_InputVerifier_inputVerifierContract = new WeakMap(), _InputVerifier_inputVerifierContractAddress = new WeakMap(), _InputVerifier_signers = new WeakMap(), _InputVerifier_threshold = new WeakMap(), _InputVerifier_eip712Domain = new WeakMap();
export function computeInputProofHex(handlesBytes32Hex, coprocessorsSignaturesHex) {
    const numHandles = handlesBytes32Hex.length;
    const numCoprocessorSigners = coprocessorsSignaturesHex.length;
    const numHandlesHexByte1 = numberToHexNoPrefix(numHandles);
    assertFhevm(numHandlesHexByte1.length === 2); // 1 byte
    const numCoprocessorSignersHexByte1 = numberToHexNoPrefix(numCoprocessorSigners);
    assertFhevm(numCoprocessorSignersHexByte1.length === 2); // 1 byte
    // Compute inputProof
    let inputProofHex = "0x" + numHandlesHexByte1 + numCoprocessorSignersHexByte1;
    // Append the list of handles
    for (let i = 0; i < numHandles; ++i) {
        const handlesBytes32HexNoPrefix = removePrefix(handlesBytes32Hex[i], "0x");
        assertFhevm(handlesBytes32HexNoPrefix.length === 2 * 32);
        inputProofHex += handlesBytes32HexNoPrefix;
    }
    // Append list of coprocessor signatures
    coprocessorsSignaturesHex.map((signatureHex) => {
        const signatureBytes65HexNoPrefix = removePrefix(signatureHex, "0x");
        if (signatureBytes65HexNoPrefix.length !== 2 * 65) {
            throw new FhevmError(`Invalid coprocessor signature: ${signatureBytes65HexNoPrefix}. Invalid length.`);
        }
        inputProofHex += signatureBytes65HexNoPrefix;
    });
    return inputProofHex;
}
//# sourceMappingURL=InputVerifier.js.map