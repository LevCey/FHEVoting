"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InputVerifier_inputVerifierContract, _InputVerifier_inputVerifierContractAddress, _InputVerifier_signers, _InputVerifier_threshold, _InputVerifier_eip712Domain;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputVerifier = void 0;
exports.computeInputProofHex = computeInputProofHex;
const ethers_1 = require("ethers");
const constants_js_1 = require("../../constants.js");
const eip712_js_1 = require("../../ethers/eip712.js");
const address_js_1 = require("../../utils/address.js");
const bytes_js_1 = require("../../utils/bytes.js");
const error_js_1 = require("../../utils/error.js");
const hex_js_1 = require("../../utils/hex.js");
const math_js_1 = require("../../utils/math.js");
const string_js_1 = require("../../utils/string.js");
const abiInputVerifier = [
    "function getCoprocessorSigners() view returns (address[])",
    "function getThreshold() view returns (uint256)",
    "function eip712Domain() view returns (bytes1,string,string,uint256,address,bytes32,uint256[])",
];
class InputVerifier {
    constructor(runner, inputVerifierContractAddress) {
        _InputVerifier_inputVerifierContract.set(this, void 0);
        _InputVerifier_inputVerifierContractAddress.set(this, void 0);
        _InputVerifier_signers.set(this, void 0);
        _InputVerifier_threshold.set(this, void 0);
        _InputVerifier_eip712Domain.set(this, void 0);
        (0, address_js_1.assertIsAddress)(inputVerifierContractAddress, "inputVerifierContractAddress");
        __classPrivateFieldSet(this, _InputVerifier_inputVerifierContractAddress, inputVerifierContractAddress, "f");
        __classPrivateFieldSet(this, _InputVerifier_inputVerifierContract, new ethers_1.ethers.Contract(inputVerifierContractAddress, abiInputVerifier, runner), "f");
    }
    get runner() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_inputVerifierContract, "f").runner);
        return __classPrivateFieldGet(this, _InputVerifier_inputVerifierContract, "f").runner;
    }
    static async create(runner, inputVerifierContractAddress) {
        const inputVerifier = new InputVerifier(runner, inputVerifierContractAddress);
        await inputVerifier.initialize();
        return inputVerifier;
    }
    async initialize() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_signers, "f") === undefined, `InputVerifier wrapper already initialized`);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_threshold, "f") === undefined, `InputVerifier wrapper already initialized`);
        const signers = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierContract, "f").getCoprocessorSigners();
        (0, address_js_1.assertIsAddressArray)(signers);
        __classPrivateFieldSet(this, _InputVerifier_signers, signers, "f");
        const threshold = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierContract, "f").getThreshold();
        (0, math_js_1.assertIsBigUint8)(threshold);
        __classPrivateFieldSet(this, _InputVerifier_threshold, Number(threshold), "f");
        const eip712Domain = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierContract, "f").eip712Domain();
        (0, error_js_1.assertFhevm)(eip712Domain.length === 7);
        (0, string_js_1.assertIsString)(eip712Domain[0], "eip712Domain[0]");
        (0, string_js_1.assertIsString)(eip712Domain[1], "eip712Domain[1]");
        (0, string_js_1.assertIsString)(eip712Domain[2], "eip712Domain[2]");
        (0, math_js_1.assertIsBigUint256)(eip712Domain[3], "eip712Domain[3]");
        (0, address_js_1.assertIsAddress)(eip712Domain[4], "eip712Domain[4]");
        (0, bytes_js_1.assertIsBytes32String)(eip712Domain[5], "eip712Domain[5]");
        __classPrivateFieldSet(this, _InputVerifier_eip712Domain, {
            fields: Number(BigInt(eip712Domain[0])),
            name: eip712Domain[1],
            version: eip712Domain[2],
            chainId: eip712Domain[3],
            verifyingContract: eip712Domain[4],
            salt: eip712Domain[5],
        }, "f");
        (0, error_js_1.assertFhevm)(constants_js_1.default.INPUT_VERIFICATION_EIP712_DOMAIN.name === __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").name);
        (0, error_js_1.assertFhevm)(constants_js_1.default.INPUT_VERIFICATION_EIP712_DOMAIN.version === __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").version);
    }
    get address() {
        return __classPrivateFieldGet(this, _InputVerifier_inputVerifierContractAddress, "f");
    }
    get gatewayChainId() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").chainId;
    }
    get gatewayInputVerificationAddress() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").verifyingContract;
    }
    get eip712Domain() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f");
    }
    getCoprocessorSigners() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_signers, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_signers, "f");
    }
    getThreshold() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_threshold, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_threshold, "f");
    }
    verifySignatures(handlesBytes32List, userAddress, contractAddress, contractChainId, signatures) {
        (0, error_js_1.assertIsArray)(signatures);
        const domain = {
            name: this.eip712Domain.name,
            version: this.eip712Domain.version,
            chainId: this.eip712Domain.chainId,
            verifyingContract: this.eip712Domain.verifyingContract,
        };
        const types = constants_js_1.default.INPUT_VERIFICATION_EIP712_TYPE;
        const recoveredAddresses = signatures.map((signature) => {
            const sig = (0, string_js_1.ensurePrefix)(signature, "0x");
            const recoveredAddress = ethers_1.ethers.verifyTypedData(domain, types, {
                ctHandles: handlesBytes32List,
                userAddress,
                contractAddress,
                contractChainId,
            }, sig);
            return recoveredAddress;
        });
        if (!(0, eip712_js_1.isThresholdReached)(this.getCoprocessorSigners(), recoveredAddresses, this.getThreshold())) {
            throw new error_js_1.FhevmError("Coprocessor signers threshold is not reached");
        }
    }
    createCiphertextVerificationEIP712(handlesBytes32List, contractChainId, contractAddress, userAddress) {
        (0, address_js_1.assertIsAddress)(userAddress, "userAddress");
        (0, address_js_1.assertIsAddress)(contractAddress, "contractAddress");
        const eip712 = {
            domain: {
                chainId: this.gatewayChainId,
                name: this.eip712Domain.name,
                version: this.eip712Domain.version,
                verifyingContract: this.gatewayInputVerificationAddress,
            },
            types: constants_js_1.default.INPUT_VERIFICATION_EIP712_TYPE,
            message: {
                ctHandles: handlesBytes32List.map((handle) => ethers_1.ethers.zeroPadValue(ethers_1.ethers.toBeHex(handle), 32)),
                userAddress: userAddress,
                contractAddress: contractAddress,
                contractChainId: contractChainId,
            },
        };
        return eip712;
    }
}
exports.InputVerifier = InputVerifier;
_InputVerifier_inputVerifierContract = new WeakMap(), _InputVerifier_inputVerifierContractAddress = new WeakMap(), _InputVerifier_signers = new WeakMap(), _InputVerifier_threshold = new WeakMap(), _InputVerifier_eip712Domain = new WeakMap();
function computeInputProofHex(handlesBytes32Hex, coprocessorsSignaturesHex) {
    const numHandles = handlesBytes32Hex.length;
    const numCoprocessorSigners = coprocessorsSignaturesHex.length;
    const numHandlesHexByte1 = (0, hex_js_1.numberToHexNoPrefix)(numHandles);
    (0, error_js_1.assertFhevm)(numHandlesHexByte1.length === 2);
    const numCoprocessorSignersHexByte1 = (0, hex_js_1.numberToHexNoPrefix)(numCoprocessorSigners);
    (0, error_js_1.assertFhevm)(numCoprocessorSignersHexByte1.length === 2);
    let inputProofHex = "0x" + numHandlesHexByte1 + numCoprocessorSignersHexByte1;
    for (let i = 0; i < numHandles; ++i) {
        const handlesBytes32HexNoPrefix = (0, string_js_1.removePrefix)(handlesBytes32Hex[i], "0x");
        (0, error_js_1.assertFhevm)(handlesBytes32HexNoPrefix.length === 2 * 32);
        inputProofHex += handlesBytes32HexNoPrefix;
    }
    coprocessorsSignaturesHex.map((signatureHex) => {
        const signatureBytes65HexNoPrefix = (0, string_js_1.removePrefix)(signatureHex, "0x");
        if (signatureBytes65HexNoPrefix.length !== 2 * 65) {
            throw new error_js_1.FhevmError(`Invalid coprocessor signature: ${signatureBytes65HexNoPrefix}. Invalid length.`);
        }
        inputProofHex += signatureBytes65HexNoPrefix;
    });
    return inputProofHex;
}
//# sourceMappingURL=InputVerifier.js.map