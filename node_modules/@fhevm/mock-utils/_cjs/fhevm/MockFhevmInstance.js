"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MockFhevmInstance_relayerProvider, _MockFhevmInstance_readonlyRunner, _MockFhevmInstance_chainId, _MockFhevmInstance_gatewayChainId, _MockFhevmInstance_verifyingContractAddressInputVerification, _MockFhevmInstance_verifyingContractAddressDecryption, _MockFhevmInstance_contractsChainId, _MockFhevmInstance_aclContractAddress, _MockFhevmInstance_kmsVerifier, _MockFhevmInstance_inputVerifier, _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockFhevmInstance = void 0;
const ethers_1 = require("ethers");
const constants_js_1 = require("../constants.js");
const userDecrypt_js_1 = require("../relayer-sdk/relayer/userDecrypt.js");
const types_js_1 = require("../relayer-sdk/types.js");
const address_js_1 = require("../utils/address.js");
const error_js_1 = require("../utils/error.js");
const hex_js_1 = require("../utils/hex.js");
const math_js_1 = require("../utils/math.js");
const MockRelayerEncryptedInput_js_1 = require("./MockRelayerEncryptedInput.js");
const InputVerifier_js_1 = require("./contracts/InputVerifier.js");
const KMSVerifier_js_1 = require("./contracts/KMSVerifier.js");
const MockRelayer_js_1 = require("./relayer/MockRelayer.js");
class MockFhevmInstance {
    constructor(config, extra) {
        _MockFhevmInstance_relayerProvider.set(this, void 0);
        _MockFhevmInstance_readonlyRunner.set(this, void 0);
        _MockFhevmInstance_chainId.set(this, void 0);
        _MockFhevmInstance_gatewayChainId.set(this, void 0);
        _MockFhevmInstance_verifyingContractAddressInputVerification.set(this, void 0);
        _MockFhevmInstance_verifyingContractAddressDecryption.set(this, void 0);
        _MockFhevmInstance_contractsChainId.set(this, void 0);
        _MockFhevmInstance_aclContractAddress.set(this, void 0);
        _MockFhevmInstance_kmsVerifier.set(this, void 0);
        _MockFhevmInstance_inputVerifier.set(this, void 0);
        _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc.set(this, void 0);
        (0, address_js_1.assertIsAddress)(config.verifyingContractAddressInputVerification, "config.verifyingContractAddressInputVerification");
        (0, address_js_1.assertIsAddress)(config.verifyingContractAddressDecryption, "config.verifyingContractAddressDecryption");
        (0, math_js_1.assertIsNumber)(config.gatewayChainId, "config.gatewayChainId");
        __classPrivateFieldSet(this, _MockFhevmInstance_relayerProvider, extra.relayerProvider, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_readonlyRunner, extra.inputVerifier.runner, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_chainId, config.chainId, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_gatewayChainId, config.gatewayChainId, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_verifyingContractAddressInputVerification, config.verifyingContractAddressInputVerification, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_verifyingContractAddressDecryption, config.verifyingContractAddressDecryption, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_contractsChainId, config.chainId, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_aclContractAddress, config.aclContractAddress, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_kmsVerifier, extra.kmsVerifier, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_inputVerifier, extra.inputVerifier, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc, (0, types_js_1.createEIP712)(__classPrivateFieldGet(this, _MockFhevmInstance_gatewayChainId, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_verifyingContractAddressDecryption, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_contractsChainId, "f")), "f");
    }
    get chainId() {
        return __classPrivateFieldGet(this, _MockFhevmInstance_chainId, "f");
    }
    static async create(readonlyRunner, relayerProvider, config) {
        const kmsVerifier = await KMSVerifier_js_1.KMSVerifier.create(readonlyRunner, config.kmsContractAddress);
        const inputVerifier = await InputVerifier_js_1.InputVerifier.create(readonlyRunner, config.inputVerifierContractAddress);
        return new MockFhevmInstance(config, {
            relayerProvider,
            inputVerifier,
            kmsVerifier,
        });
    }
    static createEIP712(publicKey, contractAddresses, startTimestamp, durationDays, gatewayChainId, verifyingContractAddressDecryption, contractsChainId) {
        (0, address_js_1.assertIsAddressArray)(contractAddresses, "contractAddresses");
        const eip712Func = (0, types_js_1.createEIP712)(gatewayChainId, verifyingContractAddressDecryption, contractsChainId);
        const eip712 = eip712Func(publicKey, contractAddresses, startTimestamp, durationDays);
        (0, error_js_1.assertFhevm)(eip712.domain.version === constants_js_1.default.DECRYPTION_EIP712_DOMAIN.version.toString());
        (0, error_js_1.assertFhevm)(eip712.domain.name === constants_js_1.default.DECRYPTION_EIP712_DOMAIN.name);
        return eip712;
    }
    createEIP712(publicKey, contractAddresses, startTimestamp, durationDays) {
        (0, address_js_1.assertIsAddressArray)(contractAddresses, "contractAddresses");
        const eip712 = __classPrivateFieldGet(this, _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc, "f").call(this, publicKey, contractAddresses, startTimestamp, durationDays);
        (0, error_js_1.assertFhevm)(eip712.domain.version === constants_js_1.default.DECRYPTION_EIP712_DOMAIN.version.toString());
        (0, error_js_1.assertFhevm)(eip712.domain.name === constants_js_1.default.DECRYPTION_EIP712_DOMAIN.name);
        (0, error_js_1.assertFhevm)(eip712.domain.verifyingContract === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.verifyingContract);
        (0, error_js_1.assertFhevm)(eip712.domain.version === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.version);
        (0, error_js_1.assertFhevm)(eip712.domain.name === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.name);
        (0, error_js_1.assertFhevm)(BigInt(eip712.domain.chainId) === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.chainId);
        return eip712;
    }
    get relayerProvider() {
        return __classPrivateFieldGet(this, _MockFhevmInstance_relayerProvider, "f");
    }
    createEncryptedInput(contractAddress, userAddress) {
        (0, error_js_1.assertFhevm)(constants_js_1.default.INPUT_VERIFICATION_EIP712_DOMAIN.name === __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.name);
        (0, error_js_1.assertFhevm)(constants_js_1.default.INPUT_VERIFICATION_EIP712_DOMAIN.version === __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.version);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockFhevmInstance_verifyingContractAddressInputVerification, "f") === __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.verifyingContract);
        (0, error_js_1.assertFhevm)(BigInt(__classPrivateFieldGet(this, _MockFhevmInstance_gatewayChainId, "f")) === __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.chainId);
        return new MockRelayerEncryptedInput_js_1.MockRelayerEncryptedInput(this.relayerProvider, __classPrivateFieldGet(this, _MockFhevmInstance_chainId, "f"), contractAddress, userAddress, __classPrivateFieldGet(this, _MockFhevmInstance_aclContractAddress, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f"));
    }
    generateKeypair() {
        return (0, types_js_1.generateKeypair)();
    }
    getPublicKey() {
        throw new error_js_1.FhevmError("Not supported in mock mode");
    }
    getPublicParams(_bits) {
        throw new error_js_1.FhevmError("Not supported in mock mode");
    }
    async publicDecrypt(_handle) {
        throw new error_js_1.FhevmError(`publicDecrypt is not yet supported in mock mode`);
    }
    async userDecrypt(handles, _privateKey, publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays) {
        for (let i = 0; i < handles.length; ++i) {
            (0, error_js_1.assertFhevm)(typeof handles[i].handle === "string" || handles[i].handle instanceof Uint8Array, "handle is not a string or a Uint8Array");
        }
        const relayerHandles = handles.map((h) => ({
            handle: typeof h.handle === "string" ? (0, hex_js_1.toHexString)((0, hex_js_1.fromHexString)(h.handle), true) : (0, hex_js_1.toHexString)(h.handle, true),
            contractAddress: h.contractAddress,
        }));
        (0, userDecrypt_js_1.checkDeadlineValidity)(BigInt(startTimestamp), BigInt(durationDays));
        await MockFhevmInstance.verifyACLPermissions(__classPrivateFieldGet(this, _MockFhevmInstance_readonlyRunner, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_aclContractAddress, "f"), relayerHandles, userAddress);
        (0, userDecrypt_js_1.checkMaxContractAddresses)(contractAddresses);
        MockFhevmInstance.verifyHandleContractAddresses(relayerHandles, contractAddresses);
        const payloadForRequest = {
            handleContractPairs: relayerHandles,
            requestValidity: {
                startTimestamp: startTimestamp.toString(),
                durationDays: durationDays.toString(),
            },
            contractsChainId: __classPrivateFieldGet(this, _MockFhevmInstance_chainId, "f").toString(),
            contractAddresses: contractAddresses.map((c) => ethers_1.ethers.getAddress(c)),
            userAddress: ethers_1.ethers.getAddress(userAddress),
            signature: signature.replace(/^(0x)/, ""),
            publicKey: publicKey.replace(/^(0x)/, ""),
        };
        const clearTextHexList = await (0, MockRelayer_js_1.requestRelayerV1UserDecrypt)(this.relayerProvider, payloadForRequest);
        await this._verifySignature(publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays);
        const listBigIntDecryptions = clearTextHexList.map(ethers_1.ethers.toBigInt);
        const results = (0, userDecrypt_js_1.buildUserDecryptedResult)(relayerHandles.map((h) => h.handle), listBigIntDecryptions);
        return results;
    }
    async _verifySignature(publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays) {
        const eip712 = this.createEIP712(publicKey, contractAddresses, startTimestamp, durationDays);
        if (!signature.startsWith("0x")) {
            signature = "0x" + signature;
        }
        const types = {};
        types[eip712.primaryType] = eip712.types[eip712.primaryType];
        const signerAddress = ethers_1.ethers.verifyTypedData(eip712.domain, types, eip712.message, signature);
        const normalizedSignerAddress = ethers_1.ethers.getAddress(signerAddress);
        const normalizedUserAddress = ethers_1.ethers.getAddress(userAddress);
        if (normalizedSignerAddress !== normalizedUserAddress) {
            throw new error_js_1.FhevmError("Invalid EIP-712 signature!");
        }
    }
    static async verifyACLPermissions(runner, aclContractAddress, handles, userAddress) {
        const aclABI = ["function persistAllowed(bytes32 handle, address account) view returns (bool)"];
        const acl = new ethers_1.ethers.Contract(aclContractAddress, aclABI, runner);
        const verifications = handles.map(async ({ handle, contractAddress }) => {
            const ctHandleHex = ethers_1.ethers.toBeHex(ethers_1.ethers.toBigInt(handle), 32);
            const userAllowed = await acl.persistAllowed(ctHandleHex, userAddress);
            const contractAllowed = await acl.persistAllowed(ctHandleHex, contractAddress);
            if (!userAllowed) {
                throw new error_js_1.FhevmError(`User ${userAddress} is not authorized to user decrypt handle ${handle}!`);
            }
            if (!contractAllowed) {
                throw new error_js_1.FhevmError(`dapp contract ${contractAddress} is not authorized to user decrypt handle ${handle}!`);
            }
            if (userAddress === contractAddress) {
                throw new error_js_1.FhevmError(`userAddress ${userAddress} should not be equal to contractAddress when requesting decryption!`);
            }
        });
        return Promise.all(verifications).catch((e) => {
            throw e;
        });
    }
    static verifyHandleContractAddresses(handles, contractAddresses) {
        const set = new Set();
        for (let i = 0; i < contractAddresses.length; ++i) {
            const add = contractAddresses[i].toLowerCase();
            if (!set.has(add)) {
                set.add(add);
            }
        }
        for (let i = 0; i < handles.length; ++i) {
            if (!set.has(handles[i].contractAddress.toLowerCase())) {
                throw new error_js_1.FhevmError(`Contract address ${handles[i].contractAddress} associated to handle ${handles[i].handle} is not listed in the contractAddresses array argument.`);
            }
        }
    }
}
exports.MockFhevmInstance = MockFhevmInstance;
_MockFhevmInstance_relayerProvider = new WeakMap(), _MockFhevmInstance_readonlyRunner = new WeakMap(), _MockFhevmInstance_chainId = new WeakMap(), _MockFhevmInstance_gatewayChainId = new WeakMap(), _MockFhevmInstance_verifyingContractAddressInputVerification = new WeakMap(), _MockFhevmInstance_verifyingContractAddressDecryption = new WeakMap(), _MockFhevmInstance_contractsChainId = new WeakMap(), _MockFhevmInstance_aclContractAddress = new WeakMap(), _MockFhevmInstance_kmsVerifier = new WeakMap(), _MockFhevmInstance_inputVerifier = new WeakMap(), _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc = new WeakMap();
//# sourceMappingURL=MockFhevmInstance.js.map