"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FhevmExternalAPI = void 0;
const mock_utils_1 = require("@fhevm/mock-utils");
const mock_utils_2 = require("@fhevm/mock-utils");
const mock_utils_3 = require("@fhevm/mock-utils");
const ethers_1 = require("ethers");
const error_1 = require("../error");
const FhevmContractError_1 = require("./errors/FhevmContractError");
const userDecrypt_1 = require("./userDecrypt");
const hh_1 = require("./utils/hh");
const log_1 = require("./utils/log");
class FhevmExternalAPI {
    constructor(fhevmEnv) {
        Object.defineProperty(this, "_fhevmEnv", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._fhevmEnv = fhevmEnv;
    }
    get isMock() {
        return this._fhevmEnv.ethersProvider.isMock;
    }
    async createInstance() {
        return await this._fhevmEnv.createInstance();
    }
    typeof(handleBytes32) {
        return mock_utils_1.FhevmHandle.fromBytes32Hex(handleBytes32).fhevmTypeInfo.name;
    }
    async tryParseFhevmError(e, options) {
        const err = await (0, FhevmContractError_1.parseFhevmError)(this._fhevmEnv, e, options);
        if (err && options?.out !== undefined) {
            (0, log_1.logBox)(`${err.name} error`, err.longMessage, options);
        }
        return err;
    }
    revertedWithCustomErrorArgs(contractName, customErrorName) {
        const itf = this._fhevmEnv.interfaceFromName(contractName);
        if (!itf) {
            throw new error_1.HardhatFhevmError(`Unable to retreive FHEVM contrat interface for contract ${contractName}`);
        }
        return [{ interface: itf }, customErrorName];
    }
    get debugger() {
        return this._fhevmEnv.debugger;
    }
    get relayerSignerAddress() {
        return this._fhevmEnv.getRelayerSignerAddress();
    }
    parseDecryptionRequestEvents(logs) {
        if (!logs || logs.length === 0) {
            return [];
        }
        const itf = this._fhevmEnv.interfaceFromName("DecryptionOracle");
        return (0, mock_utils_2.parseDecryptionRequestEventsFromLogs)(itf, logs);
    }
    parseCoprocessorEvents(logs) {
        if (!logs || logs.length === 0) {
            return [];
        }
        const itf = this._fhevmEnv.interfaceFromName("FHEVMExecutor");
        return (0, mock_utils_2.parseCoprocessorEventsFromLogs)(itf, logs);
    }
    async awaitDecryptionOracle() {
        if (this._fhevmEnv.hre.network.name === "localhost") {
            await mock_utils_3.relayer.requestFhevmAwaitDecryptionOracle(this._fhevmEnv.hre.ethers.provider);
        }
        else {
            await this._fhevmEnv.decryptionOracle.awaitDecryptionOracle();
        }
    }
    createEncryptedInput(contractAddress, userAddress) {
        return this._fhevmEnv.instance.createEncryptedInput(contractAddress, userAddress);
    }
    createEIP712(publicKey, contractAddresses, startTimestamp, durationDays) {
        return this._fhevmEnv.instance.createEIP712(publicKey, contractAddresses, startTimestamp, durationDays);
    }
    generateKeypair() {
        return this._fhevmEnv.instance.generateKeypair();
    }
    async userDecrypt(handles, privateKey, publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays) {
        return await this._fhevmEnv.instance.userDecrypt(handles, privateKey, publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays);
    }
    async userDecryptEbool(handleBytes32, contractAddress, user, options) {
        const addr = await ethers_1.ethers.resolveAddress(contractAddress);
        const decryptedResults = await (0, userDecrypt_1.userDecryptHandleBytes32)(this._fhevmEnv, [{ handleBytes32, contractAddress: addr, fhevmType: mock_utils_1.FhevmType.ebool }], user, options);
        if (!(handleBytes32 in decryptedResults)) {
            throw new error_1.HardhatFhevmError(`Failed to retrieve decrypted value for ebool handle '${handleBytes32}' from the DecryptedResults response.`);
        }
        if (typeof decryptedResults[handleBytes32] !== "boolean") {
            throw new error_1.HardhatFhevmError(`Unexpected type for decrypted value of ebool handle '${handleBytes32}': expected a boolean, but got '${typeof decryptedResults[handleBytes32]}' instead.`);
        }
        return decryptedResults[handleBytes32];
    }
    async userDecryptEuint(fhevmType, handleBytes32, contractAddress, user, options) {
        const addr = await ethers_1.ethers.resolveAddress(contractAddress);
        const decryptedResults = await (0, userDecrypt_1.userDecryptHandleBytes32)(this._fhevmEnv, [{ handleBytes32, contractAddress: addr, fhevmType }], user, options);
        const fhevmTypeInfo = (0, mock_utils_1.getFhevmTypeInfo)(fhevmType);
        if (!(handleBytes32 in decryptedResults)) {
            throw new error_1.HardhatFhevmError(`Failed to retrieve decrypted value for ${fhevmTypeInfo.name} handle '${handleBytes32}' from the DecryptedResults response.`);
        }
        if (typeof decryptedResults[handleBytes32] !== "bigint") {
            throw new error_1.HardhatFhevmError(`Unexpected type for decrypted value of ${fhevmTypeInfo.name} handle '${handleBytes32}': expected a bigint, but got '${typeof decryptedResults[handleBytes32]}' instead.`);
        }
        return decryptedResults[handleBytes32];
    }
    async userDecryptEbytes(fhevmType, handleBytes32, contractAddress, user, options) {
        const addr = await ethers_1.ethers.resolveAddress(contractAddress);
        const decryptedResults = await (0, userDecrypt_1.userDecryptHandleBytes32)(this._fhevmEnv, [{ handleBytes32, contractAddress: addr, fhevmType }], user, options);
        const fhevmTypeInfo = (0, mock_utils_1.getFhevmTypeInfo)(fhevmType);
        if (!(handleBytes32 in decryptedResults)) {
            throw new error_1.HardhatFhevmError(`Failed to retrieve decrypted value for ${fhevmTypeInfo.name} handle '${handleBytes32}' from the DecryptedResults response.`);
        }
        if (typeof decryptedResults[handleBytes32] !== "string") {
            throw new error_1.HardhatFhevmError(`Unexpected type for decrypted value of ${fhevmTypeInfo.name} handle '${handleBytes32}': expected a hex string, but got '${typeof decryptedResults[handleBytes32]}' instead.`);
        }
        if (!ethers_1.ethers.isHexString(decryptedResults[handleBytes32])) {
            throw new error_1.HardhatFhevmError(`Invalid decrypted value for ${fhevmTypeInfo.name} handle '${handleBytes32}': expected a valid hex string, but received '${decryptedResults[handleBytes32]}'.`);
        }
        return ethers_1.ethers.toBigInt(decryptedResults[handleBytes32]);
    }
    async userDecryptEaddress(handleBytes32, contractAddress, user, options) {
        const addr = await ethers_1.ethers.resolveAddress(contractAddress);
        const decryptedResults = await (0, userDecrypt_1.userDecryptHandleBytes32)(this._fhevmEnv, [{ handleBytes32, contractAddress: addr, fhevmType: mock_utils_1.FhevmType.eaddress }], user, options);
        if (!(handleBytes32 in decryptedResults)) {
            throw new error_1.HardhatFhevmError(`Failed to retrieve decrypted value for eaddress handle '${handleBytes32}' from the DecryptedResults response.`);
        }
        if (typeof decryptedResults[handleBytes32] !== "string") {
            throw new error_1.HardhatFhevmError(`Unexpected type for decrypted value of eaddress handle '${handleBytes32}': expected a hex string, but got '${typeof decryptedResults[handleBytes32]}' instead.`);
        }
        if (!ethers_1.ethers.isAddress(decryptedResults[handleBytes32])) {
            throw new error_1.HardhatFhevmError(`userDecryptEAddress failed. Decrypted value is not a valid address. Got ${decryptedResults[handleBytes32]}.`);
        }
        return decryptedResults[handleBytes32];
    }
    async getFHEVMConfig(contractAddress) {
        return (0, hh_1.getFHEVMConfig)(this._fhevmEnv.hre, contractAddress);
    }
    async getDecryptionOracleAddress(contractAddress) {
        return (0, hh_1.getDecryptionOracleAddress)(this._fhevmEnv.hre, contractAddress);
    }
    async assertCoprocessorInitialized(contract, contractName) {
        const contractAddress = await this._fhevmEnv.hre.ethers.resolveAddress(contract);
        const expectedACLAddress = this._fhevmEnv.getACLAddress();
        const expectedFHEVMExecutorAddress = this._fhevmEnv.getFHEVMExecutorAddress();
        const expectedInputVerifierAddress = this._fhevmEnv.getInputVerifierAddress();
        const expectedKMSVerifierAddress = this._fhevmEnv.getKMSVerifierAddress();
        const errorMsgPrefix = contractName === undefined ? `Contract at ${contractAddress}` : `Contract ${contractName} at ${contractAddress}`;
        const addresses = await this.getFHEVMConfig(contractAddress);
        if (addresses.ACLAddress === ethers_1.ethers.ZeroAddress ||
            addresses.FHEVMExecutorAddress === ethers_1.ethers.ZeroAddress ||
            addresses.InputVerifierAddress === ethers_1.ethers.ZeroAddress ||
            addresses.KMSVerifierAddress === ethers_1.ethers.ZeroAddress) {
            const errorMsg = `${errorMsgPrefix} is not initialized for FHE operations. Make sure it either inherits from @fhevm/solidity/config/FHEVMConfig.sol:SepoliaFHEVMConfig or explicitly calls FHE.setCoprocessor() in its constructor.`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
        const addrMismatchErrorMsg = `${errorMsgPrefix} was initialized with FHEVM contract addresses that do not match the currently deployed FHEVM contracts. This is likely due to incorrect addresses in the file @fhevm/solidity/config/FHEVMConfig.sol`;
        if (addresses.ACLAddress !== expectedACLAddress) {
            const errorMsg = `Coprocessor ACL address mismatch. ${addrMismatchErrorMsg}. ACL address: ${addresses.ACLAddress}, expected ACL address: ${expectedACLAddress}`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
        if (addresses.FHEVMExecutorAddress !== expectedFHEVMExecutorAddress) {
            const errorMsg = `Coprocessor FHEVMExecutor address mismatch. ${addrMismatchErrorMsg}. FHEVMExecutor address: ${addresses.FHEVMExecutorAddress}, expected FHEVMExecutor address: ${expectedFHEVMExecutorAddress}`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
        if (addresses.InputVerifierAddress !== expectedInputVerifierAddress) {
            const errorMsg = `Coprocessor InputVerifier address mismatch. ${addrMismatchErrorMsg}. InputVerifier address: ${addresses.InputVerifierAddress}, expected InputVerifier address: ${expectedInputVerifierAddress}`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
        if (addresses.KMSVerifierAddress !== expectedKMSVerifierAddress) {
            const errorMsg = `Coprocessor KMSVerifier address mismatch. ${addrMismatchErrorMsg}. KMSVerifier address: ${addresses.KMSVerifierAddress}, expected KMSVerifier address: ${expectedKMSVerifierAddress}`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
    }
    async assertDecryptionOracleInitialized(contract, contractName) {
        const contractAddress = await this._fhevmEnv.hre.ethers.resolveAddress(contract);
        const address = await this.getDecryptionOracleAddress(contractAddress);
        const errorMsgPrefix = contractName === undefined ? `Contract at ${contractAddress}` : `Contract ${contractName} at ${contractAddress}`;
        if (address === ethers_1.ethers.ZeroAddress) {
            const errorMsg = `${errorMsgPrefix} is not initialized for Decryption Oracle operations. Make sure it explicitly calls FHE.setDecryptionOracle() in its constructor.`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
        const expectedAddress = this._fhevmEnv.getDecryptionOracleAddress();
        const addrMismatchErrorMsg = `${errorMsgPrefix} was initialized with a Decryption Oracle address that do not match the currently deployed Decryption Oracle contract.`;
        if (address !== expectedAddress) {
            const errorMsg = `Coprocessor DecryptionOracle address mismatch. ${addrMismatchErrorMsg}. DecryptionOracle address: ${address}, expected DecryptionOracle address: ${expectedAddress}`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
    }
}
exports.FhevmExternalAPI = FhevmExternalAPI;
//# sourceMappingURL=FhevmExternalAPI.js.map