"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupMockUsingCoreContractsArtifacts = setupMockUsingCoreContractsArtifacts;
const mock_utils_1 = require("@fhevm/mock-utils");
const debug_1 = __importDefault(require("debug"));
const ethers_1 = require("ethers");
const picocolors = __importStar(require("picocolors"));
const constants_1 = __importDefault(require("../../constants"));
const error_1 = require("../../error");
const error_2 = require("../error");
const ethers_2 = require("../utils/ethers");
const addresses_1 = require("./addresses");
const debug = (0, debug_1.default)("@fhevm/hardhat:setup");
function __logDeploy(contractName, contractAddress, artifactPath) {
    debug(`Deploy ${picocolors.cyanBright(contractName)} at ${contractAddress} using artifact ${artifactPath}`);
}
function __logAlreadyDeployed(contractName, contractAddress, artifactPath) {
    debug(`${picocolors.cyanBright(contractName)} is already deployed at ${contractAddress} using artifact ${artifactPath}`);
}
async function __tryDeploy(ethersProvider, contractName, contractAddress, artifactPath, bytecode) {
    try {
        const deployedBytecode = await ethersProvider.getCodeAt(contractAddress);
        if (deployedBytecode === bytecode) {
            __logAlreadyDeployed(contractName, contractAddress, artifactPath);
            return {
                deployed: true,
                alreadyDeployed: true,
            };
        }
        else {
            (0, error_2.assertHHFhevm)(deployedBytecode === "0x", `${contractName} contract's bytecode at ${contractAddress} is not empty.`);
            __logDeploy(contractName, contractAddress, artifactPath);
            await ethersProvider.setCodeAt(contractAddress, bytecode);
            return {
                deployed: true,
                alreadyDeployed: false,
            };
        }
    }
    catch (e) {
        debug(`Deploy ${contractName} at address ${contractAddress} using artifact at ${artifactPath} failed.`);
        throw e;
    }
}
function __logCallFuncFailed(contractName, contractAddress, funcName) {
    debug(`${picocolors.bgRedBright(picocolors.bold("ERROR"))} invalid deployed ${contractName} contact at ${contractAddress}. Function ${funcName} does not exist.`);
}
async function __tryCallGetFHEVMExecutorAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getFHEVMExecutorAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getFHEVMExecutorAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE_NAME} contracts.`);
    }
}
async function __tryCallGetACLAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getACLAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getACLAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE_NAME} contracts.`);
    }
}
async function __tryCallGetFHEGasLimitAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getFHEGasLimitAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getFHEGasLimitAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE_NAME} contracts.`);
    }
}
async function __tryCallGetInputVerifierAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getInputVerifierAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getInputVerifierAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE_NAME} contracts.`);
    }
}
async function setupMockUsingCoreContractsArtifacts(ethersProvider, fhevmAddresses, fhevmSigners, fhevmPaths) {
    const FHEVMExecutorAddress = fhevmAddresses.FHEVMConfig.FHEVMExecutorAddress;
    const aclAddress = fhevmAddresses.FHEVMConfig.ACLAddress;
    const kmsVerifierAddress = fhevmAddresses.FHEVMConfig.KMSVerifierAddress;
    const inputVerifierAddress = fhevmAddresses.FHEVMConfig.InputVerifierAddress;
    const fheGasLimitAddress = fhevmAddresses.FHEGasLimitAddress;
    const decryptionOracleAddress = (0, addresses_1.getDecryptionOracleAddress)();
    const execArtifact = await fhevmPaths.getFhevmCoreContractsArtifact("FHEVMExecutor");
    await __tryDeploy(ethersProvider, "FHEVMExecutor", FHEVMExecutorAddress, execArtifact.path, execArtifact.artifact.deployedBytecode);
    const fhevmExecutorReadOnly = new ethers_1.ethers.Contract(FHEVMExecutorAddress, execArtifact.artifact.abi, ethersProvider.provider);
    const precompiledACLAddress = (await fhevmExecutorReadOnly.getACLAddress());
    const precompiledFHEGasLimitAddress = (await fhevmExecutorReadOnly.getFHEGasLimitAddress());
    const precompiledInputVerifierAddress = (await fhevmExecutorReadOnly.getInputVerifierAddress());
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, precompiledACLAddress, aclAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, precompiledFHEGasLimitAddress, fheGasLimitAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, precompiledInputVerifierAddress, inputVerifierAddress);
    const aclArtifact = await fhevmPaths.getFhevmCoreContractsArtifact("ACL");
    await __tryDeploy(ethersProvider, "ACL", aclAddress, aclArtifact.path, aclArtifact.artifact.deployedBytecode);
    const kmsArtifact = await fhevmPaths.getFhevmCoreContractsArtifact("KMSVerifier");
    const kmsDeployment = await __tryDeploy(ethersProvider, "KMSVerifier", kmsVerifierAddress, kmsArtifact.path, kmsArtifact.artifact.deployedBytecode);
    const inputArtifact = await fhevmPaths.getFhevmCoreContractsArtifact("InputVerifier");
    const inputVerifierDeployment = await __tryDeploy(ethersProvider, "InputVerifier", inputVerifierAddress, inputArtifact.path, inputArtifact.artifact.deployedBytecode);
    const fheGasLimitArtifact = await fhevmPaths.getFhevmCoreContractsArtifact("FHEGasLimit");
    await __tryDeploy(ethersProvider, "FHEGasLimit", fheGasLimitAddress, fheGasLimitArtifact.path, fheGasLimitArtifact.artifact.deployedBytecode);
    const decryptionOracleArtifact = await fhevmPaths.getZamaFheOracleSolidityArtifact("DecryptionOracle");
    await __tryDeploy(ethersProvider, "DecryptionOracle", decryptionOracleAddress, decryptionOracleArtifact.path, decryptionOracleArtifact.artifact.deployedBytecode);
    const aclReadOnly = new ethers_1.ethers.Contract(aclAddress, aclArtifact.artifact.abi, ethersProvider.provider);
    const fheGasLimitReadOnly = new ethers_1.ethers.Contract(fheGasLimitAddress, fheGasLimitArtifact.artifact.abi, ethersProvider.provider);
    const inputVerifierReadOnly = new ethers_1.ethers.Contract(inputVerifierAddress, inputArtifact.artifact.abi, ethersProvider.provider);
    const kmsVerifierReadOnly = new ethers_1.ethers.Contract(kmsVerifierAddress, kmsArtifact.artifact.abi, ethersProvider.provider);
    const decryptionOracleReadOnly = new ethers_1.ethers.Contract(decryptionOracleAddress, decryptionOracleArtifact.artifact.abi, ethersProvider.provider);
    const aclFHEVMExecutorAddress = await __tryCallGetFHEVMExecutorAddress(aclReadOnly, "ACL", aclAddress);
    const fheGasLimitFHEVMExecutorAddress = await __tryCallGetFHEVMExecutorAddress(fheGasLimitReadOnly, "FHEGasLimit", fheGasLimitAddress);
    const fhevmExecutorACLAddress = await __tryCallGetACLAddress(fhevmExecutorReadOnly, "FHEVMExecutor", FHEVMExecutorAddress);
    const fhevmExecutorFHEGasLimitAddress = await __tryCallGetFHEGasLimitAddress(fhevmExecutorReadOnly, "FHEVMExecutor", FHEVMExecutorAddress);
    const fhevmExecutorInputVerifierAddress = await __tryCallGetInputVerifierAddress(fhevmExecutorReadOnly, "FHEVMExecutor", FHEVMExecutorAddress);
    __checkHardCodedAddress("ACL", aclAddress, aclFHEVMExecutorAddress, FHEVMExecutorAddress);
    __checkHardCodedAddress("FHEGasLimit", fheGasLimitAddress, fheGasLimitFHEVMExecutorAddress, FHEVMExecutorAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, fhevmExecutorACLAddress, aclAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, fhevmExecutorFHEGasLimitAddress, fheGasLimitAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, fhevmExecutorInputVerifierAddress, inputVerifierAddress);
    const gatewayDecryptionAddress = (0, addresses_1.getGatewayDecryptionAddress)();
    const gatewayChainId = (0, addresses_1.getGatewayChainId)();
    const kmsInitialThreshold = (0, addresses_1.getKMSThreshold)();
    const kmsSigners = fhevmSigners.kms;
    if (kmsSigners.length !== 1) {
        throw new error_1.HardhatFhevmError(`Expecting 1 KMS Signer. Got ${kmsSigners.length} instead.`);
    }
    const coprocessorSigners = fhevmSigners.coprocessor;
    if (coprocessorSigners.length !== 1) {
        throw new error_1.HardhatFhevmError(`Expecting 1 Coprocessor Signer. Got ${coprocessorSigners.length} instead.`);
    }
    const zero = fhevmSigners.zero;
    const one = fhevmSigners.one;
    const kmsOne = kmsVerifierReadOnly.connect(one);
    const kmsOwner = await kmsVerifierReadOnly.owner();
    const kmsDeployer = fhevmSigners.zeroAddress;
    const kmsDeployerSigner = zero;
    const expectedKmsOwner = fhevmSigners.oneAddress;
    const expectedKmsOwnerSigner = one;
    if (kmsDeployment.alreadyDeployed) {
        if (kmsOwner !== expectedKmsOwner) {
            throw new error_1.HardhatFhevmError(`Wrong KMSVerifier owner address. Got ${kmsOwner}, expected ${expectedKmsOwner}`);
        }
    }
    else {
        if (kmsOwner !== kmsDeployer) {
            throw new error_1.HardhatFhevmError(`Wrong KMSVerifier owner address. Got ${kmsOwner}, expected ${kmsDeployer}`);
        }
    }
    if (kmsOwner !== fhevmSigners.oneAddress) {
        const kmsZero = kmsVerifierReadOnly.connect(kmsDeployerSigner);
        let tx = await kmsZero.transferOwnership(expectedKmsOwnerSigner);
        await tx.wait();
        tx = await kmsOne.acceptOwnership();
        await tx.wait();
        tx = await kmsOne.reinitialize(gatewayDecryptionAddress, gatewayChainId, kmsSigners, kmsInitialThreshold);
        await tx.wait();
    }
    (0, error_2.assertHHFhevm)((await kmsVerifierReadOnly.getThreshold()) === BigInt((0, addresses_1.getKMSThreshold)()));
    const _kmsSigners = await kmsVerifierReadOnly.getKmsSigners();
    await (0, ethers_2.assertSignersMatchAddresses)(kmsSigners, _kmsSigners);
    const inputVerifierVerifyingContractSource = (0, addresses_1.getGatewayInputVerificationAddress)();
    const inputVerifierOne = inputVerifierReadOnly.connect(one);
    const inputVerifierOwner = await inputVerifierReadOnly.owner();
    const inputVerifierDeployer = fhevmSigners.zeroAddress;
    const inputVerifierDeployerSigner = zero;
    const expectedInputVerifierOwner = fhevmSigners.oneAddress;
    const expectedInputVerifierOwnerSigner = one;
    if (inputVerifierDeployment.alreadyDeployed) {
        if (inputVerifierOwner !== expectedInputVerifierOwner) {
            throw new error_1.HardhatFhevmError(`Wrong InputVerifier owner address. Got ${inputVerifierOwner}, expected ${expectedInputVerifierOwner}`);
        }
    }
    else {
        if (inputVerifierOwner !== inputVerifierDeployer) {
            throw new error_1.HardhatFhevmError(`Wrong InputVerifier owner address. Got ${inputVerifierOwner}, expected ${inputVerifierDeployer}`);
        }
    }
    if (inputVerifierOwner !== expectedInputVerifierOwner) {
        const inputVerifierZero = inputVerifierReadOnly.connect(inputVerifierDeployerSigner);
        let tx = await inputVerifierZero.transferOwnership(expectedInputVerifierOwnerSigner);
        await tx.wait();
        tx = await inputVerifierOne.acceptOwnership();
        await tx.wait();
        tx = await inputVerifierOne.reinitialize(inputVerifierVerifyingContractSource, gatewayChainId, coprocessorSigners);
        await tx.wait();
    }
    const _inputSigners = await inputVerifierReadOnly.getCoprocessorSigners();
    await (0, ethers_2.assertSignersMatchAddresses)(coprocessorSigners, _inputSigners);
    const _inputVerifier712Domain = await inputVerifierReadOnly.eip712Domain();
    (0, mock_utils_1.assertIsEIP712Domain)(_inputVerifier712Domain, "InputVerifier", {
        name: mock_utils_1.constants.INPUT_VERIFICATION_EIP712_DOMAIN.name,
        version: mock_utils_1.constants.INPUT_VERIFICATION_EIP712_DOMAIN.version,
        chainId: BigInt(gatewayChainId),
        verifyingContract: inputVerifierVerifyingContractSource,
    });
    const _kms712Domain = await kmsVerifierReadOnly.eip712Domain();
    (0, mock_utils_1.assertIsEIP712Domain)(_kms712Domain, "KMSVerifier", {
        name: mock_utils_1.constants.DECRYPTION_EIP712_DOMAIN.name,
        version: mock_utils_1.constants.DECRYPTION_EIP712_DOMAIN.version,
        chainId: BigInt(gatewayChainId),
        verifyingContract: gatewayDecryptionAddress,
    });
    debug(`${picocolors.cyanBright("ACL")} address              : ${aclAddress}`);
    debug(`${picocolors.cyanBright("FHEVMExecutor")} address    : ${FHEVMExecutorAddress}`);
    debug(`${picocolors.cyanBright("InputVerifier")} address    : ${inputVerifierAddress}`);
    debug(`${picocolors.cyanBright("KMSVerifier")} address      : ${kmsVerifierAddress}`);
    debug(`${picocolors.cyanBright("DecryptionOracle")} address : ${decryptionOracleAddress}`);
    debug(`Gateway chainId                         : ${gatewayChainId}`);
    debug(`InputVerifier verifying contract source : ${inputVerifierVerifyingContractSource}`);
    debug(`Gateway Decryption address              : ${gatewayDecryptionAddress}`);
    return {
        ACLAddress: aclAddress,
        ACLReadOnly: aclReadOnly,
        FHEVMExecutorAddress: FHEVMExecutorAddress,
        FHEVMExecutorReadOnly: fhevmExecutorReadOnly,
        InputVerifierAddress: inputVerifierAddress,
        InputVerifierReadOnly: inputVerifierReadOnly,
        KMSVerifierAddress: kmsVerifierAddress,
        KMSVerifierReadOnly: kmsVerifierReadOnly,
        DecryptionOracleAddress: decryptionOracleAddress,
        DecryptionOracleReadOnly: decryptionOracleReadOnly,
        kmsSigners,
        coprocessorSigners,
        gatewayInputVerificationAddress: inputVerifierVerifyingContractSource,
        gatewayChainId,
        gatewayDecryptionAddress: gatewayDecryptionAddress,
    };
}
function __checkHardCodedAddress(contractName, contractAddress, hardCodedAddress, expectedHardCodedAddress) {
    if (hardCodedAddress !== expectedHardCodedAddress) {
        debug(`${picocolors.bgRedBright(picocolors.bold("ERROR"))} deployed ${contractName} contact at ${contractAddress} does not use the expected ACL address. Got ${hardCodedAddress}, expecting ${expectedHardCodedAddress}`);
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE_NAME} contracts.`);
    }
}
//# sourceMappingURL=setup.js.map