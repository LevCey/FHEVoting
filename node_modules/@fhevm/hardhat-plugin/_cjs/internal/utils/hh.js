"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeDummyAddress = computeDummyAddress;
exports.getFHEVMConfig = getFHEVMConfig;
exports.getDecryptionOracleAddress = getDecryptionOracleAddress;
exports.connectedChainId = connectedChainId;
exports.resolveNetworkConfigChainId = resolveNetworkConfigChainId;
exports.getWeb3ClientVersion = getWeb3ClientVersion;
exports.isHardhatNode = isHardhatNode;
exports.checkSupportedNetwork = checkSupportedNetwork;
const hardhat_network_helpers_1 = require("@nomicfoundation/hardhat-network-helpers");
const ethers_1 = require("ethers");
const errors_1 = require("hardhat/internal/core/errors");
const constants_1 = __importDefault(require("../../constants"));
const error_1 = require("../../error");
const error_2 = require("../error");
function computeDummyAddress() {
    return ethers_1.ethers.getAddress(ethers_1.ethers.toBeHex((BigInt(ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes("fhevm-hardhat-plugin.dummy"))) - 1n) &
        0xffffffffffffffffffffffffffffffffffffffffn, 20));
}
function computeStorageLocation(storageName) {
    const enc = ethers_1.ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [BigInt(ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(storageName))) - 1n]);
    return ethers_1.ethers.toBeHex(BigInt(ethers_1.ethers.keccak256(enc)) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00n, 32);
}
async function getAddressesFromStorage(hre, contractAddress, storageLocation, numAddresses) {
    const addresses = [];
    for (let i = 0; i < numAddresses + 1; ++i) {
        const addr = await (0, hardhat_network_helpers_1.getStorageAt)(contractAddress, BigInt(storageLocation) + BigInt(i));
        addresses.push(addr);
    }
    const errorMsg = `The contract at address ${contractAddress} has not been initialized properly. Please call FHE.setFHEVM before.`;
    if (addresses[numAddresses] !== hre.ethers.ZeroHash) {
        throw new error_1.HardhatFhevmError(errorMsg);
    }
    for (let i = 0; i < numAddresses; ++i) {
        const addr = addresses[i];
        if (typeof addr !== "string" || !hre.ethers.isBytesLike(addr) || addr.length !== 66) {
            throw new error_1.HardhatFhevmError(errorMsg);
        }
        const hex = hre.ethers.toBeHex(BigInt(addr), 20);
        try {
            addresses[i] = hre.ethers.getAddress(hex);
        }
        catch {
            throw new error_1.HardhatFhevmError(errorMsg);
        }
    }
    return addresses;
}
async function getFHEVMConfig(hre, contractAddress) {
    const fhevmConfigStorageLocation = computeStorageLocation("fhevm.storage.FHEVMConfig");
    (0, error_2.assertHHFhevm)(fhevmConfigStorageLocation === "0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600");
    const addresses = await getAddressesFromStorage(hre, contractAddress, fhevmConfigStorageLocation, 4);
    return {
        ACLAddress: addresses[0],
        FHEVMExecutorAddress: addresses[1],
        KMSVerifierAddress: addresses[2],
        InputVerifierAddress: addresses[3],
    };
}
async function getDecryptionOracleAddress(hre, contractAddress) {
    const decryptionRequestsStorageLocation = computeStorageLocation("fhevm.storage.DecryptionRequests");
    (0, error_2.assertHHFhevm)(decryptionRequestsStorageLocation === "0x5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d00");
    const addresses = await getAddressesFromStorage(hre, contractAddress, decryptionRequestsStorageLocation, 1);
    return addresses[0];
}
async function connectedChainId(hre) {
    let chainId = 0;
    try {
        chainId = await hre.ethers.provider.send("eth_chainId");
        chainId = Number(BigInt(chainId));
    }
    catch (e) {
        if (e instanceof errors_1.HardhatError) {
            if (e.number === 108) {
                return undefined;
            }
        }
        throw e;
    }
    (0, error_2.assertHHFhevm)(typeof chainId === "number");
    return chainId;
}
async function resolveNetworkConfigChainId(hre, useEthChainId) {
    if (hre.network.config.chainId === undefined) {
        const chainId = useEthChainId ? await connectedChainId(hre) : undefined;
        if (chainId === undefined) {
            if (hre.network.name === "localhost") {
                return constants_1.default.DEVELOPMENT_NETWORK_CHAINID;
            }
            throw new error_1.HardhatFhevmError(`Unable to resolve network chainId. Network name: ${hre.network.name}`);
        }
        return chainId;
    }
    return hre.network.config.chainId;
}
async function getWeb3ClientVersion(provider) {
    return await provider.send("web3_clientVersion");
}
async function isHardhatNode(networkName, chainId, provider) {
    if (networkName !== "localhost") {
        return false;
    }
    try {
        const metadata = await provider.send("hardhat_metadata");
        if (!("chainId" in metadata) || metadata.chainId !== constants_1.default.DEVELOPMENT_NETWORK_CHAINID) {
            return false;
        }
        if (!("instanceId" in metadata) || metadata.instanceId.length !== 66) {
            return false;
        }
        return true;
    }
    catch (e) {
        if (e instanceof errors_1.HardhatError) {
            if (e.number === 108) {
                return (networkName === "localhost" && (chainId === undefined || chainId === constants_1.default.DEVELOPMENT_NETWORK_CHAINID));
            }
        }
        return false;
    }
}
async function checkSupportedNetwork(hre) {
    if (hre.network.name === "hardhat") {
        return;
    }
    if (await isHardhatNode(hre.network.name, hre.network.config.chainId, hre.ethers.provider)) {
        return true;
    }
    if (hre.network.name === "localhost") {
        throw new error_1.HardhatFhevmError(`Unsupported network: The fhevm hardhat plugin only supports the default 'localhost' hardhat node with chainId=${constants_1.default.DEVELOPMENT_NETWORK_CHAINID}. Got network 'localhost' with chainId=${hre.network.config.chainId} instead.`);
    }
    throw new error_1.HardhatFhevmError(`Unsupported network: The fhevm hardhat plugin only supports the 'hardhat' network or the 'localhost' hardhat node with chainId=${constants_1.default.DEVELOPMENT_NETWORK_CHAINID}. Got network '${hre.network.name}' with chainId=${hre.network.config.chainId} instead.`);
}
//# sourceMappingURL=hh.js.map