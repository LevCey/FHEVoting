"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _FhevmEthersProvider_provider, _FhevmEthersProvider_info, _FhevmEthersProvider_savedBlockGasLimit;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FhevmEthersProvider = exports.FhevmEthersProviderType = void 0;
const debug_1 = __importDefault(require("debug"));
const ethers_1 = require("ethers");
const error_1 = require("../../error");
const anvil_1 = require("./anvil");
const hh_1 = require("./hh");
const debug = (0, debug_1.default)("@fhevm/hardhat:ethers-provider");
var FhevmEthersProviderType;
(function (FhevmEthersProviderType) {
    FhevmEthersProviderType[FhevmEthersProviderType["Unknown"] = 0] = "Unknown";
    FhevmEthersProviderType[FhevmEthersProviderType["Hardhat"] = 1] = "Hardhat";
    FhevmEthersProviderType[FhevmEthersProviderType["HardhatNode"] = 2] = "HardhatNode";
    FhevmEthersProviderType[FhevmEthersProviderType["Anvil"] = 3] = "Anvil";
})(FhevmEthersProviderType || (exports.FhevmEthersProviderType = FhevmEthersProviderType = {}));
class FhevmEthersProvider {
    constructor() {
        _FhevmEthersProvider_provider.set(this, void 0);
        _FhevmEthersProvider_info.set(this, void 0);
        _FhevmEthersProvider_savedBlockGasLimit.set(this, void 0);
    }
    static async create(hre) {
        const provider = new FhevmEthersProvider();
        __classPrivateFieldSet(provider, _FhevmEthersProvider_provider, hre.ethers.provider, "f");
        const web3ClientVersion = await (0, hh_1.getWeb3ClientVersion)(__classPrivateFieldGet(provider, _FhevmEthersProvider_provider, "f"));
        const networkName = hre.network.name;
        const isAnvil = await (0, anvil_1.isAnvilProvider)(networkName, __classPrivateFieldGet(provider, _FhevmEthersProvider_provider, "f"));
        const isNetworkHardhatNode = await (0, hh_1.isHardhatNode)(networkName, hre.network.config.chainId, hre.ethers.provider);
        const chainId = await (0, hh_1.resolveNetworkConfigChainId)(hre, true);
        let url = undefined;
        let type = FhevmEthersProviderType.Unknown;
        let methods = {};
        if (isAnvil) {
            type = FhevmEthersProviderType.Anvil;
            methods = {
                setBalance: "anvil_setBalance",
                setCode: "anvil_setCode",
                impersonateAccount: "anvil_impersonateAccount",
            };
        }
        else if (isNetworkHardhatNode) {
            type = FhevmEthersProviderType.HardhatNode;
            methods = {
                setBalance: "hardhat_setBalance",
                setCode: "hardhat_setCode",
                impersonateAccount: "hardhat_impersonateAccount",
            };
        }
        else if (networkName === "hardhat") {
            type = FhevmEthersProviderType.Hardhat;
            methods = {
                setBalance: "hardhat_setBalance",
                setCode: "hardhat_setCode",
                impersonateAccount: "hardhat_impersonateAccount",
            };
        }
        if (isAnvil || isNetworkHardhatNode) {
            url = hre.network.config.url;
            if (!url) {
                throw new error_1.HardhatFhevmError(`Unable to determine the url of network ${networkName}`);
            }
        }
        __classPrivateFieldSet(provider, _FhevmEthersProvider_info, {
            web3ClientVersion,
            type,
            methods,
            ...(url !== undefined && { url }),
            chainId,
            networkName,
        }, "f");
        return provider;
    }
    get provider() {
        if (!__classPrivateFieldGet(this, _FhevmEthersProvider_provider, "f")) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return __classPrivateFieldGet(this, _FhevmEthersProvider_provider, "f");
    }
    get info() {
        if (!__classPrivateFieldGet(this, _FhevmEthersProvider_info, "f")) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return __classPrivateFieldGet(this, _FhevmEthersProvider_info, "f");
    }
    get isMock() {
        if (!__classPrivateFieldGet(this, _FhevmEthersProvider_info, "f")) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return __classPrivateFieldGet(this, _FhevmEthersProvider_info, "f").type !== FhevmEthersProviderType.Unknown;
    }
    get isHardhatWeb3Client() {
        if (!__classPrivateFieldGet(this, _FhevmEthersProvider_info, "f")) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return (__classPrivateFieldGet(this, _FhevmEthersProvider_info, "f").type === FhevmEthersProviderType.Hardhat || __classPrivateFieldGet(this, _FhevmEthersProvider_info, "f").type === FhevmEthersProviderType.HardhatNode);
    }
    get chainId() {
        return this.info.chainId;
    }
    send(method, params) {
        return this.provider.send(method, params);
    }
    async impersonateAddressAndSetBalance(hre, address, balance) {
        if (!this.info.methods.impersonateAccount) {
            throw new error_1.HardhatFhevmError(`Network ${this.info.networkName} does not support account impersonation`);
        }
        if (!this.info.methods.setBalance) {
            throw new error_1.HardhatFhevmError(`Network ${this.info.networkName} does not support account setBalance`);
        }
        await this.provider.send(this.info.methods.impersonateAccount, [address]);
        await this.provider.send(this.info.methods.setBalance, [address, ethers_1.ethers.toBeHex(balance)]);
        if (this.info.type === FhevmEthersProviderType.Anvil) {
            const jsonRpcProvider = new ethers_1.ethers.JsonRpcProvider(this.info.url);
            jsonRpcProvider.pollingInterval = 100;
            return await jsonRpcProvider.getSigner(address);
        }
        else if (this.isHardhatWeb3Client) {
            return await hre.ethers.getSigner(address);
        }
        else {
            throw new error_1.HardhatFhevmError(`Network ${this.info.networkName} does not support account impersonation`);
        }
    }
    async setCodeAt(address, byteCode) {
        const methodName = this.info.methods.setCode;
        if (!methodName) {
            throw new error_1.HardhatFhevmError(`Network ${this.info.networkName} does not support 'setCode' method.`);
        }
        if (typeof byteCode !== "string") {
            throw new error_1.HardhatFhevmError(`Invalid contract bytecode.`);
        }
        await this.provider.send(methodName, [address, byteCode]);
    }
    async getCodeAt(address) {
        const byteCode = await this.provider.send("eth_getCode", [address, "latest"]);
        if (typeof byteCode !== "string") {
            throw new error_1.HardhatFhevmError(`Invalid contract bytecode.`);
        }
        return byteCode;
    }
    async getBlockNumber() {
        return await this.provider.getBlockNumber();
    }
    async unsetTemporaryMinimumBlockGasLimit() {
        if (!__classPrivateFieldGet(this, _FhevmEthersProvider_savedBlockGasLimit, "f")) {
            return;
        }
        try {
            await this.setBlockGasLimit(__classPrivateFieldGet(this, _FhevmEthersProvider_savedBlockGasLimit, "f"));
        }
        finally {
            __classPrivateFieldSet(this, _FhevmEthersProvider_savedBlockGasLimit, undefined, "f");
        }
    }
    async setTemporaryMinimumBlockGasLimit(minBlockGasLimit) {
        if (__classPrivateFieldGet(this, _FhevmEthersProvider_savedBlockGasLimit, "f")) {
            throw new error_1.HardhatFhevmError(`The minimum block gas limit has already been set.`);
        }
        const currentBlockGasLimit = await this.getBlockGasLimit();
        if (!currentBlockGasLimit) {
            debug(`Unable to setup minimum block gas limit.`);
            return undefined;
        }
        if (minBlockGasLimit <= currentBlockGasLimit) {
            return undefined;
        }
        debug(`Adjust block gas limit to: ${minBlockGasLimit}. Current block gas limit is too low: ${currentBlockGasLimit}`);
        await this.setBlockGasLimit(minBlockGasLimit);
        __classPrivateFieldSet(this, _FhevmEthersProvider_savedBlockGasLimit, currentBlockGasLimit, "f");
    }
    async setBlockGasLimit(blockGasLimit) {
        const blockGasLimitHex = "0x" + blockGasLimit.toString(16);
        await this.provider.send("evm_setBlockGasLimit", [blockGasLimitHex]);
        debug(`Call evm_setBlockGasLimit ${blockGasLimit}`);
    }
    async getBlockGasLimit() {
        return (await this.provider.getBlock("latest"))?.gasLimit;
    }
}
exports.FhevmEthersProvider = FhevmEthersProvider;
_FhevmEthersProvider_provider = new WeakMap(), _FhevmEthersProvider_info = new WeakMap(), _FhevmEthersProvider_savedBlockGasLimit = new WeakMap();
//# sourceMappingURL=FhevmEthersProvider.js.map