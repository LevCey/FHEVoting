"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.userDecryptHandleBytes32 = userDecryptHandleBytes32;
const mock_utils_1 = require("@fhevm/mock-utils");
const mock_utils_2 = require("@fhevm/mock-utils");
const ethers_1 = require("ethers");
const constants_1 = __importDefault(require("../constants"));
const error_1 = require("../error");
async function userDecryptHandleBytes32(fhevmEnv, handleContractPairs, user, options) {
    _assertIsContractAddressesArray(handleContractPairs);
    const userDecryptArgs = await _resolveUserDecryptOptions(fhevmEnv, options);
    const chainId = _getFhevmInstanceChainId(userDecryptArgs.instance);
    _verifyFhevmHandleContractPairs(handleContractPairs, chainId);
    const { signature, contractAddresses } = await _computeUserSignatureAndContractAddresses(handleContractPairs, user, userDecryptArgs);
    const userAddress = await user.getAddress();
    const handles = handleContractPairs.map((p) => {
        return { handle: p.handleBytes32, contractAddress: p.contractAddress };
    });
    const decryptedHandles = await userDecryptArgs.instance.userDecrypt(handles, userDecryptArgs.keypair.privateKey, userDecryptArgs.keypair.publicKey, signature, contractAddresses, userAddress, userDecryptArgs.startTimestamp, userDecryptArgs.durationDays);
    return decryptedHandles;
}
async function _resolveUserDecryptOptions(fhevmEnv, options) {
    let instance;
    if (options?.instance) {
        instance = options.instance;
    }
    else if (fhevmEnv.getInstanceOrUndefined()) {
        instance = fhevmEnv.instance;
    }
    else {
        instance = await fhevmEnv.externalFhevmAPI.createInstance();
    }
    let keypair;
    if (options?.keypair !== undefined) {
        keypair = { ...options.keypair };
        mock_utils_2.utils.verifyKeypair(keypair);
    }
    else {
        keypair = instance.generateKeypair();
    }
    const startTimestamp = options?.validity?.startTimestamp || mock_utils_2.utils.timestampNow();
    const durationDays = options?.validity?.durationDays || constants_1.default.DEFAULT_DURATION_DAYS;
    const startTimestampNumber = mock_utils_2.utils.toUIntNumber(startTimestamp, "startTimeStamp");
    const durationDaysNumber = mock_utils_2.utils.toUIntNumber(durationDays, "durationDays");
    return {
        instance,
        keypair,
        startTimestamp: startTimestampNumber,
        durationDays: durationDaysNumber,
    };
}
async function _computeUserSignatureAndContractAddresses(contractAddresses, user, userDecryptArgs) {
    if (contractAddresses.length === 0) {
        throw new error_1.HardhatFhevmError("Empty list of contract addresses.");
    }
    const contractAddressesSortUnique = _buildDeterministicContractAddressesList(contractAddresses);
    if (contractAddressesSortUnique.length === 0) {
        throw new error_1.HardhatFhevmError("Empty list of valid contract addresses.");
    }
    const eip712 = userDecryptArgs.instance.createEIP712(userDecryptArgs.keypair.publicKey, contractAddressesSortUnique, userDecryptArgs.startTimestamp, userDecryptArgs.durationDays);
    const signature = await user.signTypedData(eip712.domain, { UserDecryptRequestVerification: eip712.types.UserDecryptRequestVerification }, eip712.message);
    return {
        signature,
        contractAddresses: contractAddressesSortUnique,
    };
}
function _getFhevmInstanceChainId(instance) {
    const dummyEIP712 = instance.createEIP712("", [ethers_1.ethers.ZeroAddress], 0, 0);
    return dummyEIP712.message.contractsChainId;
}
function _buildDeterministicContractAddressesList(contractAddresses) {
    const set = new Set();
    for (let i = 0; i < contractAddresses.length; ++i) {
        const ca = contractAddresses[i];
        let contractAddress;
        if (typeof ca === "string") {
            contractAddress = ca;
        }
        else {
            contractAddress = ca.contractAddress;
        }
        const add = ethers_1.ethers.getAddress(contractAddress);
        if (!set.has(add)) {
            set.add(add);
        }
    }
    return [...set].sort((a, b) => {
        const addrA = a.toLowerCase();
        const addrB = b.toLowerCase();
        if (addrA < addrB) {
            return -1;
        }
        if (addrA > addrB) {
            return 1;
        }
        return 0;
    });
}
function _assertIsContractAddressesArray(contractAddresses) {
    if (contractAddresses.length === 0) {
        throw new error_1.HardhatFhevmError("Empty list of contract addresses.");
    }
    for (let i = 0; i < contractAddresses.length; ++i) {
        const ca = contractAddresses[i];
        let contractAddress;
        if (typeof ca === "string") {
            contractAddress = ca;
        }
        else {
            contractAddress = ca.contractAddress;
        }
        mock_utils_2.utils.assertIsAddress(contractAddress, "contractAddress");
    }
}
function _verifyFhevmHandleContractPairs(handleContractPairs, chainId) {
    if (handleContractPairs.length === 0) {
        throw new error_1.HardhatFhevmError("Empty list of handle/contract pairs.");
    }
    for (let i = 0; i < handleContractPairs.length; ++i) {
        const pair = handleContractPairs[i];
        mock_utils_1.FhevmHandle.verify(pair.handleBytes32, {
            ...(pair.fhevmType !== undefined && { fhevmType: pair.fhevmType }),
            ...(chainId !== undefined && { chainId: chainId }),
        });
        mock_utils_2.utils.assertIsAddress(pair.contractAddress, "contractAddress");
    }
}
//# sourceMappingURL=userDecrypt.js.map