import { CoprocessorEvent, DecryptionRequestEvent, FhevmContractName, FhevmTypeEbytes, FhevmTypeEuint, FhevmTypeName } from "@fhevm/mock-utils";
import type { DecryptedResults } from "@zama-fhe/relayer-sdk/node";
import type { EIP712, FhevmInstance, HandleContractPair, RelayerEncryptedInput } from "@zama-fhe/relayer-sdk/node";
import { AddressLike, ethers as EthersT } from "ethers";
import { FHEVMConfig, FhevmUserDecryptOptions, HardhatFhevmRuntimeDebugger, HardhatFhevmRuntimeEnvironment } from "../types";
import { FhevmEnvironment } from "./FhevmEnvironment";
import { FhevmContractError } from "./errors/FhevmContractError";
/**
 * Public External API
 */
export declare class FhevmExternalAPI implements HardhatFhevmRuntimeEnvironment {
    private _fhevmEnv;
    constructor(fhevmEnv: FhevmEnvironment);
    get isMock(): boolean;
    createInstance(): Promise<FhevmInstance>;
    typeof(handleBytes32: string): FhevmTypeName;
    tryParseFhevmError(e: unknown, options?: {
        encryptedInput?: RelayerEncryptedInput;
        out?: "stderr" | "stdout" | "console";
    }): Promise<FhevmContractError | undefined>;
    revertedWithCustomErrorArgs(contractName: FhevmContractName, customErrorName: string): [{
        interface: EthersT.Interface;
    }, string];
    get debugger(): HardhatFhevmRuntimeDebugger;
    get relayerSignerAddress(): string;
    parseDecryptionRequestEvents(logs: (EthersT.EventLog | EthersT.Log)[] | null | undefined): DecryptionRequestEvent[];
    parseCoprocessorEvents(logs: (EthersT.EventLog | EthersT.Log)[] | null | undefined): CoprocessorEvent[];
    awaitDecryptionOracle(): Promise<void>;
    createEncryptedInput(contractAddress: string, userAddress: string): RelayerEncryptedInput;
    createEIP712(publicKey: string, contractAddresses: string[], startTimestamp: string | number, durationDays: string | number): EIP712;
    generateKeypair(): {
        publicKey: string;
        privateKey: string;
    };
    userDecrypt(handles: HandleContractPair[], privateKey: string, publicKey: string, signature: string, contractAddresses: string[], userAddress: string, startTimestamp: string | number, durationDays: string | number): Promise<DecryptedResults>;
    userDecryptEbool(handleBytes32: string, contractAddress: EthersT.AddressLike, user: EthersT.Signer, options?: FhevmUserDecryptOptions): Promise<boolean>;
    userDecryptEuint(fhevmType: FhevmTypeEuint, handleBytes32: string, contractAddress: EthersT.AddressLike, user: EthersT.Signer, options?: FhevmUserDecryptOptions): Promise<bigint>;
    userDecryptEbytes(fhevmType: FhevmTypeEbytes, handleBytes32: string, contractAddress: EthersT.AddressLike, user: EthersT.Signer, options?: FhevmUserDecryptOptions): Promise<bigint>;
    userDecryptEaddress(handleBytes32: string, contractAddress: EthersT.AddressLike, user: EthersT.Signer, options?: FhevmUserDecryptOptions): Promise<string>;
    getFHEVMConfig(contractAddress: string): Promise<FHEVMConfig>;
    getDecryptionOracleAddress(contractAddress: string): Promise<string>;
    assertCoprocessorInitialized(contract: AddressLike, contractName?: string): Promise<void>;
    assertDecryptionOracleInitialized(contract: AddressLike, contractName?: string): Promise<void>;
}
//# sourceMappingURL=FhevmExternalAPI.d.ts.map